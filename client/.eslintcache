[{"/Users/ahmedaldulaimy/Documents/mothership/client/src/index.js":"1","/Users/ahmedaldulaimy/Documents/mothership/client/src/useCannon.js":"2","/Users/ahmedaldulaimy/Documents/mothership/client/src/urls.js":"3","/Users/ahmedaldulaimy/Documents/mothership/client/src/serviceWorkerRegistration.js":"4","/Users/ahmedaldulaimy/Documents/mothership/client/src/utils.js":"5","/Users/ahmedaldulaimy/Documents/mothership/client/src/controlComponents.js":"6"},{"size":21184,"mtime":1611103912112,"results":"7","hashOfConfig":"8"},{"size":1606,"mtime":1611098578860,"results":"9","hashOfConfig":"8"},{"size":286,"mtime":1611098639330,"results":"10","hashOfConfig":"8"},{"size":5064,"mtime":1611023570669,"results":"11","hashOfConfig":"8"},{"size":1015,"mtime":1611102486824,"results":"12","hashOfConfig":"8"},{"size":3120,"mtime":1611099542974,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"16","usedDeprecatedRules":"17"},"1fb5j5q",{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"17"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"17"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"17"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"17"},"/Users/ahmedaldulaimy/Documents/mothership/client/src/index.js",["29","30","31","32","33","34","35"],"import { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport * as serviceWorkerRegistration from \"./serviceWorkerRegistration\";\nimport { Canvas, extend, useFrame, useThree } from \"react-three-fiber\";\nimport React, { Component, useRef, useState } from \"react\";\nimport { toast, ToastContainer } from \"react-toastify\";\nimport useEventListener from \"@use-it/event-listener\";\nimport { Provider, useCannon } from \"./useCannon\";\nimport LoadingScreen from \"react-loading-screen\";\nimport { isBrowser } from \"react-device-detect\";\nimport \"react-toastify/dist/ReactToastify.css\";\nimport { useDrag } from \"react-use-gesture\";\nimport { Html } from \"@react-three/drei\";\nimport io from \"socket.io-client\";\nimport ReactDOM from \"react-dom\";\nimport * as CANNON from \"cannon\";\nimport * as THREE from \"three\";\nimport urls from \"./urls.js\";\nimport axios from \"axios\";\nimport \"./index.css\";\nimport {unboxAPIConfigObject, get3DPosition} from \"./utils.js\";\nimport {CameraControls, ConfigForm} from \"./controlComponents.js\";\n\nlet humanNames = require(\"human-names\");\n\n// establish a socket connection\nconst socket = io(`${urls.socketURL}`);\n\n// global variables for distinguishing mouse clicks from mouse drags\nlet initX, initY;\n\n// the robot 3D component (visualized as a ball)\nfunction Robot(props) {\n\n    const { camera, mouse } = useThree();\n    const [position, setPosition] = useState(props.identity.position);\n    const [hovered, setHover] = useState(false);\n    const [quaternion, setQuaternion] = useState([0, 0, 0, 0]);\n\n    // use cannon js so it can be used in the physics engine\n    const { ref, body } = useCannon(\n        { bodyProps: { mass: 5 } },\n        (body) => {\n            body.addShape(new CANNON.Box(new CANNON.Vec3(1, 1, 1)));\n            body.position.set(...[position.x, position.y, position.z]);\n        },\n        []\n    );\n\n    // detect clicks and drags of the robot\n    const bind = useDrag(\n        ({ event, offset: [,], xy: [x, y], first, last }) => {\n\n            // get the 3d world coordinate of the 2d mouse click\n            const pos = get3DPosition({\n                screenX: mouse.x,\n                screenY: mouse.y,\n                camera,\n            });\n\n            // check if the robot has been dragged sufficiently (more than 0.05 in x and y)\n            const positionHasChanged =\n                Math.abs(pos.x - initX) > 0.05 && Math.abs(pos.y - initY) > 0.05;\n\n            // if this is the first click (onMouseDown)\n            // then set mass to 0 so we can lift the robot up (z direction)\n            if (first) {\n                body.mass = 0;\n                body.updateMassProperties();\n                initX = pos.x;\n                initY = pos.y;\n            }\n            // if this is the last click (onMouseUp)\n            // then set mass to 5 so the robot can fall\n            else if (last) {\n                body.mass = 5;\n                body.updateMassProperties();\n\n                // if this was a drag, log a position change\n                if (positionHasChanged) {\n                    props.logPositionChange(props.identity.id, body.position);\n                }\n                // otherwise set the robot as selected\n                else {\n                    props.logSelection(props.identity);\n                }\n            }\n            // if this robot was selected and has been sufficiently dragged, move it\n            if (!first && positionHasChanged && props.active) {\n                body.position.set(pos.x, pos.y, -0.7);\n            }\n        },\n        { pointerEvents: true }\n    );\n\n    useFrame(() => {\n        // sync cannon body position with three js (keep the physics engine state updated)\n        const deltaX = Math.abs(body.position.x - position.x);\n        const deltaY = Math.abs(body.position.y - position.y);\n        const deltaZ = Math.abs(body.position.z - position.z);\n\n        // if the updates happen too frequently it'll stress the processor\n        if (deltaX > 0.001 || deltaY > 0.001 || deltaZ > 0.001) {\n            setPosition(body.position.clone());\n        }\n        const bodyQuaternion = body.quaternion.toArray();\n        const quaternionDelta = bodyQuaternion\n            .map((n, idx) => Math.abs(n - quaternion[idx]))\n            .reduce((acc, curr) => acc + curr);\n        if (quaternionDelta > 0.01) {\n            setQuaternion(body.quaternion.toArray());\n        }\n    });\n\n    // return the robot component\n    return (\n        <mesh\n            onPointerOver={() => setHover(true)}\n            onPointerOut={() => setHover(false)}\n            ref={ref}\n            castShadow={true}\n            receiveShadow={false}\n            position={[position.x, position.y, position.z]}\n            quaternion={quaternion}\n            {...bind()}\n            onClick={(e) => {e.stopPropagation();}}\n        >\n            <dodecahedronBufferGeometry attach=\"geometry\" />\n            <meshLambertMaterial\n                attach=\"material\"\n                color={hovered ? \"rgb(61,96,221)\" : props.identity.color}\n            />\n\n            <Html scaleFactor={50}>\n                <div className=\"content\">\n                    {props.active && <status-indicator active pulse />}\n                    {props.identity.humanName}\n                </div>\n            </Html>\n        </mesh>\n    );\n}\n\n// the plane 3D component which everything sits on\nfunction Plane(props) {\n\n    // assign a mass of 0 to indicate a fixed object\n    const { ref } = useCannon({ bodyProps: { mass: 0 } }, (body) => {\n        body.addShape(new CANNON.Plane());\n        body.position.set(...props.position);\n    });\n\n    // return the plane component. If clicked, call onPlaneClick (see Index component)\n    return (\n        <mesh\n            ref={ref}\n            receiveShadow\n            position={props.position}\n            onClick={props.onPlaneClick}\n        >\n            <planeBufferGeometry attach=\"geometry\" args={[100, 100]} />\n            <meshPhongMaterial attach=\"material\" color=\"#087E8B\" />\n        </mesh>\n    );\n}\n\n// the index component encapsulating lights, plane, and robots\nfunction Index(props) {\n    const { mouse, camera } = useThree();\n\n    // get the 3d world coordinate of the 2d mouse click\n    const onPlaneClick = () => {\n        const position = get3DPosition({\n            screenX: mouse.x,\n            screenY: mouse.y,\n            camera,\n        });\n\n        // send the click event to your parent to handle it\n        props.handlePlaneClick(position);\n    };\n\n    // helper that zooms in and out when mouse is scrolled\n    const mouseWheelScrolled = (e) => {\n        let delta = e.wheelDelta;\n        delta = delta / 240;\n        delta = -delta;\n        if (delta <= 0) {\n            delta -= camera.position.z * 0.1;\n        } else {\n            delta += camera.position.z * 0.1;\n        }\n        if (camera.position.z + delta > 1 && camera.position.z + delta < 200) {\n            camera.translateZ(delta);\n        }\n    };\n\n    // wait for the mouse scroll and call mouseWheelScrolled when it occurs\n    useEventListener(\"wheel\", mouseWheelScrolled);\n\n    // add lights, robots, and plane then return the component\n    // note that the prop objects is the array of robots passed from the parent\n    return (\n        <React.Fragment>\n            <Provider>\n                <ambientLight intensity={0.75} />\n                <spotLight\n                    castShadow={true}\n                    intensity={0.8}\n                    position={[0, -50, 200]}\n                    angle={Math.PI / 15}\n                    penumbra={1}\n                />\n\n                {props.objects.map((t) => (\n                    <Robot\n                        key={t.id}\n                        identity={t}\n                        active={t.id === props.selectedObjectID}\n                        logPositionChange={props.logPositionChange}\n                        logSelection={props.logSelection}\n                    />\n                ))}\n\n                <Plane position={[0, 0, -5]} onPlaneClick={onPlaneClick} />\n            </Provider>\n        </React.Fragment>\n    );\n}\n\n// entry point of the react app\n// handles all the communication from/to server\nclass App extends Component {\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            objects: [], // list of object configs to be turned into Robot components in Index\n            selectedObjectID: \"\", // id of the object currently selected\n            humanName: \"\", // human name of the selected object\n            color: \"\", // color of the selected object\n            rating: 0, // rating or speed of the selected object\n            clickToAdd: true, // use clicks on plane creates a new object\n            loading: true, // loading screen is showing\n        };\n    }\n\n    // once mounted, the component should connect to server socket\n    componentDidMount = async () => {\n\n        // once connected, fetch all the objects and display them on screen\n        socket.on(\"connect\", () => {\n\n            console.log(\"got connection to socket\");\n            this.fetchObjects();\n\n            // if disconnected for whatever reason, show loading screen\n            // note once scoket reconnects, fetchObjects call above will hide loading screen\n            socket.on(\"disconnect\", () => {\n                console.log(\"lost connection to socket\");\n                this.setState({ loading: true });\n            });\n\n        });\n\n        // once you get a new robot from server, unpack it and insert it into our state\n        socket.on(\"newRobot\", (realtimeUpdate) => {\n            console.log(\"got new robot from server\", realtimeUpdate);\n\n            const objData = realtimeUpdate.document;\n\n            // unbox server object into a robot object\n            const newRobot = unboxAPIConfigObject(objData);\n\n            // add this robot object to list of objects\n            this.setState((state) => ({\n                objects: [...state.objects, newRobot],\n            }));\n\n            // show a notification that new robot has been created\n            toast.dark(\"Created \" + newRobot.humanName);\n\n        });\n\n        // once you get a robot was deleted server, remove it from our state\n        socket.on(\"deletedRobot\", (realtimeUpdate) => {\n\n            // deleting an object from state requires\n            // copying current state\n            let objects = [...this.state.objects];\n            let index = -1;\n\n            // find the index of the deleted object using id in our state\n            objects.find((o, i) => {\n                if (o.id === realtimeUpdate.id) {\n                    index = i;\n                    return true; // stop searching\n                }\n            });\n\n            // object was never in our state, stop here\n            if (index === -1){return}\n\n            // get the object that is to be deleted from our state\n            const objectToBeDeleted = objects.splice(index, 1)[0];\n\n            // establish a new state without that object\n            this.setState({ objects: objects }, function () {\n                // in case the object deleted was selected, deselect it\n                if (objectToBeDeleted.id === this.state.selectedObjectID) {\n                    this.setState({\n                        selectedObjectID: \"\",\n                        humanName: \"\",\n                        color: \"\",\n                        rating: 0,\n                    });\n                }\n\n                // show a notification that a robot has been deleted\n                toast.error(\"Deleted \" + objectToBeDeleted.humanName);\n            });\n        });\n\n        socket.on(\"modifiedRobot\", (realtimeUpdate) => {\n\n            // modifying an object from state requires\n            // copying current state\n            let objects = [...this.state.objects];\n            let index = -1;\n\n            // find the index of the modified object using id in our state\n            objects.find((o, i) => {\n                if (o.id === realtimeUpdate.id) {\n                    let item = { ...objects[i] };\n                    // update the objects information\n                    item = { ...item, ...realtimeUpdate.updatedFields };\n                    objects[i] = item;\n                    index = i;\n                    return true; // stop searching\n                }\n            });\n\n            // object was never in our state, stop here\n            if (index === -1){return}\n\n            // like delete, modifying an object alone won't trigger a new render\n            // we have to delete it from array and then insert it to the end\n            const objectModified = objects.splice(index, 1)[0];\n\n            // establish a new state with that modified object\n            this.setState({ objects: objects }, function () {\n                // in case the object modified was selected, select it again\n                if (objectModified.id === this.state.selectedObjectID) {\n                    this.setState(\n                        {\n                            objects: [...objects, objectModified],\n                            selectedObjectID: objectModified.id,\n                            humanName: objectModified.humanName,\n                            color: objectModified.color,\n                            rating: objectModified.rating,\n                        },\n                        function () {\n                            // call back after state change, show notification\n                            toast.warn(\"Modified \" + objectModified.humanName);\n                        }\n                    );\n                } else {\n                    this.setState({ objects: [...objects, objectModified] }, function () {\n                        // call back after state change, show notification\n                        toast.warn(\"Modified \" + objectModified.humanName);\n                    });\n                }\n            });\n        });\n    };\n\n\n    // triggers a get api call to get all robot configs from server\n    async fetchObjects() {\n        // console.log(\"Fetching objects\");\n        try {\n            const response = await axios.get(`${urls.baseURL}`);\n\n            if (response.status === 200) {\n\n                // unbox each received object config into a robot object (see utils.js)\n                let objects = response.data.map((t) => unboxAPIConfigObject(t));\n                objects = objects.filter(function (el) {return el.id != null;});\n\n                // erase all the objects and set the loading to off in case it was loading\n                this.setState({\n                    objects: objects,\n                    loading: false,\n                });\n\n            } else {\n                console.log(\"Error fetching objects, got response \"+response.status);\n            }\n        } catch (error) {\n            console.log(\"Error with fetching: \", error);\n        }\n    }\n\n    // trigger a new state change if an object gets selected\n    // called by child component Index\n    logSelection = (identity) => {\n        // console.log(identity.id, \"now selected\");\n        this.setState({\n            selectedObjectID: identity.id,\n            humanName: identity.humanName,\n            color: identity.color,\n            rating: identity.rating,\n        });\n    };\n\n    // tell the server an object position has been modified\n    // an actual state update is made when the socket receives\n    // modified robot message\n    logPositionChange = async (key, position) => {\n        console.log(key, \"changed\", position);\n        if (!key || !position) {\n            return;\n        }\n        try {\n            await axios.put(`${urls.baseURL}\\\\${key}`, {\n                position: position,\n            });\n        } catch (error) {\n            console.log(\"Error with changing location: \", error);\n        }\n    };\n\n    // tell the server an object has been created\n    // an actual state update is made when the socket receives\n    // new robot message\n    logCreation = async (newObj) => {\n        if (!newObj) {return}\n        try {\n            await axios.post(`${urls.baseURL}`, {\n                humanName: newObj.humanName,\n                color: newObj.color,\n                position: newObj.position,\n            });\n        } catch (error) {\n            console.log(\"Error with creating object: \", error);\n        }\n    };\n\n    // creates or selects a robot when\n    // the user clicks on the plane\n    handlePlaneClick(position) {\n\n        if (this.state.selectedObjectID) { // if something is selected it will deselect it\n            this.setState({\n                selectedObjectID: \"\",\n                humanName: \"\",\n                color: \"\",\n                rating: 0,\n            });\n        } else if (this.state.clickToAdd) { // changed by the ConfigForm component\n\n            // creates some default parameters of new object and sends\n            // a request to the sever to create it via logCreation\n            const addedObject = {\n                humanName: humanNames.allRandomEn(),\n                position: position,\n                color: \"white\",\n            };\n\n            this.logCreation(addedObject);\n        }\n    }\n\n    // tells the server to delete the selected robot\n    async deleteObject() {\n\n        if (!this.state.selectedObjectID) {return}\n\n        try {\n            const response = await axios.delete(\n                `${urls.baseURL}\\\\${this.state.selectedObjectID}`\n            );\n        } catch (error) {\n            console.log(\"Error with deleting object: \", error);\n        }\n    }\n\n    async updateObject(prop) {\n        if (!prop.key) {\n            return;\n        }\n\n        try {\n            const response = await axios.put(`${urls.baseURL}\\\\${prop.key}`, {\n                humanName: prop.humanName,\n                color: prop.color,\n                rating: prop.rating,\n            });\n        } catch (error) {\n            console.log(\"Error with editing object: \", error);\n        }\n    }\n\n    changeHumanName = (newName) => {\n        this.updateObject({ key: this.state.selectedObjectID, humanName: newName });\n    };\n\n    changeColor = (newColor) => {\n        this.updateObject({ key: this.state.selectedObjectID, color: newColor });\n    };\n\n    changeRating = (newRating) => {\n        this.updateObject({ key: this.state.selectedObjectID, rating: newRating });\n    };\n\n    changeAddMode = (addMode) => {\n        this.setState({ clickToAdd: addMode });\n    };\n\n    render() {\n        return (\n            <>\n                <LoadingScreen\n                    loading={this.state.loading}\n                    bgColor=\"#f1f1f1\"\n                    spinnerColor=\"#9ee5f8\"\n                    textColor=\"#676767\"\n                    logoSrc=\"/logo512.png\"\n                    text=\"\"\n                >\n                    Loaded\n                </LoadingScreen>\n\n                <Canvas\n                    camera={{ fov: 45, position: [0, -70, 30] }}\n                    onCreated={({ gl }) => {\n                        gl.setPixelRatio(window.devicePixelRatio || 2);\n                        gl.shadowMap.enabled = true;\n                        gl.shadowMap.type = THREE.PCFSoftShadowMap;\n                    }}\n                >\n                    {isBrowser && (\n                        <CameraControls selectedSomething={this.state.selectedObjectID !== \"\"} />\n                    )}\n\n                    <Index\n                        selectedObjectID={this.state.selectedObjectID}\n                        objects={this.state.objects}\n                        logPositionChange={this.logPositionChange.bind(this)}\n                        logSelection={this.logSelection.bind(this)}\n                        handlePlaneClick={this.handlePlaneClick.bind(this)}\n                    />\n                </Canvas>\n\n                <ConfigForm\n                    name={this.state.selectedObjectID}\n                    humanName={this.state.humanName}\n                    changeHumanName={this.changeHumanName.bind(this)}\n                    color={this.state.color}\n                    changeColor={this.changeColor.bind(this)}\n                    rating={this.state.rating}\n                    changeRating={this.changeRating.bind(this)}\n                    deleteObject={this.deleteObject.bind(this)}\n                    changeAddMode={this.changeAddMode.bind(this)}\n                    clickToAdd={this.state.clickToAdd}\n                />\n\n                <ToastContainer\n                    position={(isBrowser && \"top-right\") || \"bottom-left\"}\n                    autoClose={2000}\n                    hideProgressBar={true}\n                    newestOnTop={false}\n                    closeOnClick\n                    rtl={false}\n                    pauseOnFocusLoss={false}\n                    draggable\n                    pauseOnHover\n                />\n            </>\n        );\n    }\n}\n\nif (module.hot) {module.hot.accept();}\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://cra.link/PWA\nserviceWorkerRegistration.register();\n",["36","37"],"/Users/ahmedaldulaimy/Documents/mothership/client/src/useCannon.js",[],["38","39"],"/Users/ahmedaldulaimy/Documents/mothership/client/src/urls.js",[],"/Users/ahmedaldulaimy/Documents/mothership/client/src/serviceWorkerRegistration.js",[],"/Users/ahmedaldulaimy/Documents/mothership/client/src/utils.js",[],"/Users/ahmedaldulaimy/Documents/mothership/client/src/controlComponents.js",[],{"ruleId":"40","severity":1,"message":"41","line":1,"column":10,"nodeType":"42","messageId":"43","endLine":1,"endColumn":23},{"ruleId":"40","severity":1,"message":"44","line":3,"column":18,"nodeType":"42","messageId":"43","endLine":3,"endColumn":24},{"ruleId":"40","severity":1,"message":"45","line":4,"column":28,"nodeType":"42","messageId":"43","endLine":4,"endColumn":34},{"ruleId":"46","severity":1,"message":"47","line":294,"column":33,"nodeType":"48","messageId":"49","endLine":294,"endColumn":35},{"ruleId":"46","severity":1,"message":"47","line":332,"column":33,"nodeType":"48","messageId":"49","endLine":332,"endColumn":35},{"ruleId":"40","severity":1,"message":"50","line":480,"column":19,"nodeType":"42","messageId":"43","endLine":480,"endColumn":27},{"ruleId":"40","severity":1,"message":"50","line":494,"column":19,"nodeType":"42","messageId":"43","endLine":494,"endColumn":27},{"ruleId":"51","replacedBy":"52"},{"ruleId":"53","replacedBy":"54"},{"ruleId":"51","replacedBy":"55"},{"ruleId":"53","replacedBy":"56"},"no-unused-vars","'OrbitControls' is defined but never used.","Identifier","unusedVar","'extend' is defined but never used.","'useRef' is defined but never used.","array-callback-return","Array.prototype.find() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","'response' is assigned a value but never used.","no-native-reassign",["57"],"no-negated-in-lhs",["58"],["57"],["58"],"no-global-assign","no-unsafe-negation"]